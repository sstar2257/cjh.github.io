---
title: find-loop-min
date: 2019-04-15 14:24:29
updated: 2019-04-15 14:24:29
tags: graph
---

### 无向图中的最小环
1. dfs+剪枝，当遇到起始点时即有环。
2. Floyd 算法保证了最外层循环到 k 时所有顶点间已求得以 0…k-1 为中间点的最短路径。一个环至少有3个顶点，设某环编号最大的顶点为 L ，在环中直接与之相连的两个顶点编号分别为 M 和 N (M,N < L)，则最大编号为 L 的最小环长度即为 Graph(M,L) + Graph(N,L) + Dist(M,N) ，其中 Dist(M,N) 表示以 0…L-1 号顶点为中间点时的最短路径，刚好符合 Floyd 算法最外层循环到 k=L 时的情况，则此时对 M 和 N 循环所有编号小于 L 的顶点组合即可找到最大编号为 L 的最小环。再经过最外层 k 的循环，即可找到整个图的最小环。根据Floyed的原理，在最外层循环做了k-1次之后，dis[i][j]则代表了i到j的路径中所有结点编号都小于k的最短路径  
3. 最小环：从一个点出发,经过一条简单路径回到起点成为环.图的最小环就是所有环中长度最小的.

 

　　怎样求最小环呢?

 

　　1传统的解决方法(dijkstra):
        任意一个最小环环的权值，我们都可以看成两个有边相连的结点i、j的直接距离加上i、j间不包含边(边i->j)的最短路径。求最短路径我们第一个想到的就Dijkstra算法。而Dijkstra所求的是一个点到所有点的最短距离。用Dijkstra所求的i、j的最短距离一定是i、j的直接距离(如果i，j连通)，所以我们需要先将i、j的边从图中删除(若i，j不连通，则不用删除)，再用Dijkstra求新图中i、j的最短距离即可。所以我们每次在图中选取一条边，把它从图中删掉．然后对删掉的那条边所对应的2点进行Dijkstra，也就是m次Dijkstra。

 

　　2.floyd求最小环:

 

        抛开Dijkstra算法，进而我们想到用Floyd算法。我们知道，Floyd算法在进行时会不断更新矩阵dist(k)。设dist[k，i，j]表示从结点i到结点j且满足所有中间结点，它们均属于集合{1，2，⋯ ，k}的一条最短路径的权。其中dist[0，i,j ]即为初始状态i到j的直接距离。对于一个给定的赋权有向图， 求出其中权值和最小的一个环。我们可以将任意一个环化成如下形式：u->k->v ->(x1-> x2-> ⋯ xm1)-> u(u与k、k与v都是直接相连的)，其中v ->(x1-> 2-> ⋯ m)-> u是指v到u不经过k的一种路径。

 

        在u，k，v确定的情况下，要使环权值最小， 则要求 (x1一>x2->⋯一>xm)->u路径权值最小．即要求其为v到u不经过k的最短路径，则这个经过u，k，v的环的最短路径就是：[v到u不包含k的最短距离]+dist[O，u，k]+dist[O，k，v]。我们用Floyd只能求出任意2点间满足中间结点均属于集合{1，2，⋯ ，k}的最短路径，可是我们如何求出v到u不包含k的最短距离呢?
         现在我们给k加一个限制条件：k为当前环中的序号最大的节点(简称最大点)。因为k是最大点，所以当前环中没有任何一个点≥k，即所有点都<k。因为v->(x1->x2->......xm)->u属于当前环，所以x1，x2，⋯ ，xm<k，即x1，x2．⋯。xm≤k一1。这样，v到u的最短距离就可以表示成dist[k一1 ,u,v]。dist[k一1,v,u]表示的是从v到u且满足所有中间结点均属于集合{1，2，⋯ ，k一1}的一条最短路径的权。接下来，我们就可以求出v到u不包含k的最短距离了。这里只是要求不包含k，而上述方法用的是dist[k一1，v，u]，求出的路径永远不会包含k+l，k+2，⋯ 。万一所求的最小环中包含k+1，k+2，⋯ 怎么办呢?的确，如果最小环中包含比k大的节点，在当前u,k,v所求出的环显然不是那个最小环。然而我们知道，这个最小环中必定有一个最大点kO，也就是说，虽然当前k没有求出我们所需要的最小环，但是当我们从k做到kO的时候，这个环上的所有点都小于kO了．也就是说在k=kO时一定能求出这个最小环。我们用一个实例来说明：假设最小环为1—3—4—5—6—2—1。的确，在u=l，v=4，k=3时，k<6，dist[3，4，1]的确求出的不是4—5—6—2—1这个环，但是，当u=4，v=6，k=5或u=5，v=2，k=6时，dist[k，v，u]表示的都是这条最短路径.所以我们在Floyd以后，只要枚举u．v，k三个变量即可求出最小环。时间复杂度为O(n3)。我们可以发现，Floyd和最后枚举u，v,k三个变量求最小环的过程都是u,v,k三个变量，所以我们可以将其合并。这样，我们在k变量变化的同时，也就是进行Floyd算法的同时，寻找最大点为k的最小环。 
